/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package dnn.memory

import chisel3._
import chisel3.util._

trait ISAConstants{
  val INST_BITS = 160

  val OP_BITS = 3

  val M_DEP_BITS         = 4
  val M_ID_BITS          = 2
  val M_SRAM_OFFSET_BITS = 16
  val M_DRAM_OFFSET_BITS = 32
  val M_SIZE_BITS        = 32
  val M_STRIDE_BITS      = 16
  val M_PAD_BITS         = 4

  val C_UOP_BGN_BITS = 13
  val C_UOP_END_BITS = 14
  val C_ITER_BITS    = 14
  val C_AIDX_BITS    = 11
  val C_IIDX_BITS    = 11
  val C_WIDX_BITS    = 10
  val C_ALU_DEC_BITS = 2 // FIXME: there should be a SHL and SHR instruction
  val C_ALU_OP_BITS  = 3
  val C_ALU_IMM_BITS = 16

  val Y = true.B
  val N = false.B

  val OP_L = 0.asUInt(OP_BITS.W)
  val OP_S = 1.asUInt(OP_BITS.W)
  val OP_G = 2.asUInt(OP_BITS.W)
  val OP_F = 3.asUInt(OP_BITS.W)
  val OP_A = 4.asUInt(OP_BITS.W)
  val OP_X = 5.asUInt(OP_BITS.W)
//
  val ALU_OP_NUM = 5
  val ALU_OP     = Enum(ALU_OP_NUM)

  val M_ID_U = 0.asUInt(M_ID_BITS.W)
  val M_ID_W = 1.asUInt(M_ID_BITS.W)
  val M_ID_I = 2.asUInt(M_ID_BITS.W)
  val M_ID_A = 3.asUInt(M_ID_BITS.W)
}


/** ISA.
  *
  * This is the VTA ISA, here we specify the cares and dont-cares that makes
  * decoding easier. Since instructions are quite long 128-bit, we could generate
  * these based on ISAConstants.
  *
  * FIXME: VSHX should be replaced by VSHR and VSHL once we modify the compiler
  * TODO: Add VXOR to clear accumulator
  */
object ISA extends ISAConstants {

  /** ISAConstants.
    *
    * These constants are used for decoding (parsing) fields on instructions.
    */


  def LUOP = BitPat("b_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_???????0_0????000")

  def LWGT = BitPat("b_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_???????0_1????000")

  def LINP = BitPat("b_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_???????1_0????000")

  def LACC = BitPat("b_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_???????1_1????000")

  def SOUT = BitPat("b_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_?????001")

  def GEMM = BitPat("b_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_?????010")

  def VMIN = BitPat("b_????????_????????_??00????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_?????100")

  def VMAX = BitPat("b_????????_????????_??01????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_?????100")

  def VADD = BitPat("b_????????_????????_??10????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_?????100")

  def VSHX = BitPat("b_????????_????????_??11????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_?????100")

  def FNSH = BitPat("b_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_????????_?????011")


  class MemDecode extends Bundle {
    val xpad_1      = UInt(M_PAD_BITS.W)
    val xpad_0      = UInt(M_PAD_BITS.W)
    val ypad_1      = UInt(M_PAD_BITS.W)
    val ypad_0      = UInt(M_PAD_BITS.W)
    val xstride     = UInt(M_STRIDE_BITS.W)
    val xsize       = UInt(M_SIZE_BITS.W)
    val ysize       = UInt(M_SIZE_BITS.W)
    val empty_0     = UInt(7.W) // derive this
    val dram_offset = UInt(M_DRAM_OFFSET_BITS.W)
    val sram_offset = UInt(M_SRAM_OFFSET_BITS.W)
    val id          = UInt(M_ID_BITS.W)
    val push_next   = Bool( )
    val push_prev   = Bool( )
    val pop_next    = Bool( )
    val pop_prev    = Bool( )
    val op          = UInt(OP_BITS.W)
  }

  object MemDecode {
  def default(): MemDecode = {
      val y = Wire(new MemDecode())
    y.xpad_0  :=  0.U
    y.xpad_1  :=  0.U
    y.ypad_0  :=  0.U
    y.ypad_1  :=  0.U
    y.xstride  :=  48.U
    y.xsize  :=  48.U
    y.ysize  :=  1.U
    y.empty_0  :=  0.U
    y.dram_offset  :=  64.U
    y.sram_offset  :=  0.U
    y.id  :=  3.U
    y.push_next  :=  0.U
    y.push_prev  :=  0.U
    y.pop_next  :=  0.U
    y.pop_prev  :=  0.U
    y.op  :=  0.U
    y
    }
  }


  /** LoadDecode.
    *
    * Decode dependencies, type and sync for Load module.
    */
  class LoadDecode extends Module with ISAConstants {
    val io  = IO(new Bundle {
      val inst      = Input(UInt(INST_BITS.W))
      val push_next = Output(Bool( ))
      val pop_next  = Output(Bool( ))
      val isInput   = Output(Bool( ))
      val isWeight  = Output(Bool( ))
      val isSync    = Output(Bool( ))
    })
    val dec = io.inst.asTypeOf(new MemDecode)
    io.push_next := dec.push_next
    io.pop_next := dec.pop_next
    io.isInput := io.inst === LINP & dec.xsize =/= 0.U
    io.isWeight := io.inst === LWGT & dec.xsize =/= 0.U
    io.isSync := (io.inst === LINP | io.inst === LWGT) & dec.xsize === 0.U
  }

}

